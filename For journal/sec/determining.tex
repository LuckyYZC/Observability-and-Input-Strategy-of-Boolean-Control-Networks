% !Mode\dots ``TeX:UTF-8''
% !TEX root = ../bare_jrnl.tex

\section{Algorithm for online observability}
\label{sec:deter}
To  determine  online observability of \BCN s, one needs to determine $\Ks(\Ded(\Delta_M,\varepsilon,\mathsf{o}^{j}(0)))$ for every non-empty $\Ded(\Delta_M,\varepsilon, \mathsf{o}^{j}(0))$. 

%\subsection{Input-labelled graph}
We start with input-labelled graph $\mathcal{G}=(\mathcal{V}, \mathcal{E}, \mathcal{L})$.

\begin{definition}[Input-labelled Graph]
Let $\mathcal{V}$, $\mathcal{E}$ and $\mathcal{L}$ be the vertex set, the edge set and the labelling function of an input-labelled graph $\mathcal{G}=(\mathcal{V}, \mathcal{E}, \mathcal{L})$. $\mathcal{G}$ is called the input-labelled graph of the \BCN\, if 
\begin{itemize}
\item  $\mathcal{V}=\{\mathsf{S}\in\bigcup_{j=0}^{(2^{n} -1)} 2^{\Ded(\Delta_M,\varepsilon,\delta^j_{2^{n}} )}|\ \Ks(\mathsf{S})\ne \infty\}$;
\item  $\mathcal{E}=\{(\mathsf{S}_1,\mathsf{S}_2)\in \mathcal{V}\times \mathcal{V}|$ there is an $\mathsf{i} \in \Delta_L$ such that $|\Ded\left(\mathsf{S}_1,\mathsf{i},\varepsilon\right)|=|\mathsf{S}_1|$ and for every $\Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o}^{j})\neq \emptyset$, $\Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o}^{j})\in \mathcal{V}$, the $\mathsf{S}_2\in\{\Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o})| \Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o})\neq \emptyset, \mathsf{o}\in \Delta_N\}\}$;
\item  $\mathcal{L}:\mathcal{E}\mapsto 2^{\Delta_L}=(\mathsf{S}_1,\mathsf{S}_2)\mapsto\{\mathsf{i}\in \Delta_L|$ $|\Ded\left(\mathsf{S}_1,\mathsf{i},\varepsilon\right)|=|\mathsf{S}_1|$ and for every $\Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o}^{j})\neq \emptyset$, $\Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o}^{j})\in \mathcal{V}$, the $\mathsf{S}_2\in\{\Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o})| \Ded(\mathsf{S}_1,\mathsf{i},\mathsf{o})\neq \emptyset, \mathsf{o}\in \Delta_N\}\}$.
 \end{itemize}
\end{definition}

\begin{figure}[thpb]
      \centering
      \framebox{\parbox{3in}{
		\centerline{\includegraphics[scale=0.090]{figures/Fig4.png}}
	}}
      \caption{Part of the input-labelled graph, where the green, black, orange, blue edges are labelled with $\{\delta_4^0\}$, $\{\delta_4^1\}$, $\{\delta_4^2\}$ and $\{\delta_4^3\}$ respectively.}
      \label{fig:4}
\end{figure}

Intuitively, $\mathcal{V}$ represents a set of the state sets, that for every $\mathsf{S}\in \mathcal{V}$, $\Ks(\mathsf{S})\ne \infty$ and for every $\mathsf{s}\in\mathsf{S}$, $\mathsf{s}$ produces the same output. $\mathcal{E}$ represents the relation of the state sets which belong to $\mathcal{V}$, and $\mathcal{L}$ labels every $\mathsf{e} \in\mathcal{E}$ with a set of inputs. %Then, based on the definition of the input-labelled graph, we have a \BCN\ is online observable iff every non-empty $\Ded(\Delta_M,\varepsilon, \mathsf{o}^{j}(0))\in \mathcal{V}$.%Thus we can determine $\Ks(\Ded(\Delta_N,\varepsilon,\mathsf{o}^{j}(0)))$ of every non-empty $\Ded(\Delta_N,\varepsilon, \mathsf{o}^{j}(0))$ by checking the input-labelled graph.

%From the {\em Lemma \ref{lemm:1}}, we have that if for the set of states $\mathsf{S}^1$ there does not exist any $k^{1}\ge 0$ such that $\mathsf{S}^{1}$ is $k^{1}$-step determinable, and $\mathsf{S}^{1}\subseteq \mathsf{S}^{2}$. Then there does not exist any $k^{2}\ge 0$ that make $\mathsf{S}^{2}$ $k^{2}$-step determinable. Therefore, i

% \subsection{Determination algorithm}
Based on the definition of the input-labelled graph, we have a \BCN\ $\BB$ is online observable iff every non-empty $\Ded(\Delta_M,\varepsilon, \mathsf{o}^{j}(0))\in \mathcal{V}$.
 Then, we propose the {\bf Algorithm~\ref{alg:1}} to determine the online observability. We construct the input-labelled graph $\mathcal{G}=(\mathcal{V}, \mathcal{E}, \mathcal{L})$ at first., and then check whether every non-empty $\Ded(\Delta_M,\varepsilon, \mathsf{o}^{j}(0))\in \mathcal{V}$.
 
 In the process of constructing the input-labelled graph for a \BCN\ $\BB$, we build the vertexes which consist of a smaller number of states before building the vertexes which consist of a greater number of states.
\begin{itemize}
\item  Because, once we find a $\mathsf{S}$ that $\Ks(\mathsf{S})= \infty$, i.e. $\mathsf{S}\notin \mathcal{V}$, and as there exists $\mathsf{o}^{j}\in \Delta_N$, such that $\mathsf{S}\subseteq \Ded(\Delta_M,\varepsilon, \mathsf{o}^{j})$, we have $\Ks(\Ded(\Delta_M,\varepsilon, \mathsf{o}^{j}))= \infty$, i.e. $\Ded(\Delta_M,\varepsilon, \mathsf{o}^{j}(0))\notin \mathcal{V}$ based on the {\em Lemma \ref{lemm:1}}, i.e. the \BCN\ $\BB$ is not online observable.
\item  And we can determine the scope of $\Ri(\mathsf{S})$ if we have determined $\Ri(\mathsf{S}')$ for every $\mathsf{S}'\subset\mathsf{S}$ based on the {\em Lemma \ref{lemm:2}}. With the scope of $\Ri(\mathsf{S})$ we can determine the $\Ks(\mathsf{S})$ more easily.
 \end{itemize} %, and it can find all paths to determine $\mathsf{s}(0)$ if the \BCN\ is online observable.

\begin{algorithm}[h]
\caption{Determination algorithm}
\begin{algorithmic}[1]
\REQUIRE 
The updating rules of a \BCN
\ENSURE  
The input-labelled graph of this \BCN
\STATE Boolean value $Ob=$ true 
\STATE integer $i$ , $j$, $z=1$\
\STATE array $VertexArray[\ ]$, $InputArray[\ ]$
\STATE {\sf buildvertex}($z$)
\STATE $VertexArray=${\sf buildvertex}($++z$)
\WHILE {($VertexArray!=$Null)}
\FOR{($i=0$; $i<arraysize(VertexArray)$; $i++$)}
\IF{($i==2$)}
\STATE $InputArray$ = $\Delta_M$ 
\ELSE

\STATE Find $InputArray$ by other vertexes

\ENDIF
\FOR{($j=0$; $j<arraysize(InputArray)$; $j++$)}
\STATE Check $VertexArray[i]$ by $InputArray[j]$ 
\STATE Build edges for $VertexArray[i]$ 
\ENDFOR
\IF {($VertexArray[i]$ has not any edge)}
\STATE  $Ob=$ false 
\STATE Return Null
\ENDIF
\ENDFOR
\STATE $VertexArray=${\sf buildvertex}($++z$)
\ENDWHILE
\STATE Return $\Delta_M$\
\end{algorithmic}
 \label{alg:1}
\end{algorithm}


\begin{algorithm}[h!]
\caption{{\sf buildvertex}(integer $z$)}
\begin{algorithmic}[1]
\REQUIRE 
The number of states $z$
\ENSURE  
The vertexes with $z$ states producing the same outputs 
\STATE  Build all vertexes with $z$ states producing the same outputs 
\IF{(Failed to build)} 
\STATE  Return Null
\ELSE 
\STATE  Classify these vertexes
\STATE Sort the states in these vertexes
\STATE Sort these vertexes
\STATE Return vertexes
\ENDIF 
\end{algorithmic}
 \label{alg:2}
\end{algorithm}

Some details of {\bf Algorithm~\ref{alg:1}} and {\bf Algorithm~\ref{alg:2}}:
\begin{itemize}
\item Build all vertexes with $z$ states producing the same outputs :
\begin{description}
\item[Step 1] For every non-empty $\Ded(\Delta_M,\varepsilon,\mathsf{o}^{j})$, if $z>|\Ded(\Delta_M,\varepsilon,\mathsf{o}^{j})|$, then we could not get any set from $\Ded(\Delta_M,\varepsilon,\mathsf{o}^{j})$. Else we get $\frac{(|\Ded(\Delta_M,\varepsilon,o_j)|)!}{z!\times (|\Ded(\Delta_M,\varepsilon,o_j)|-z)!}$ sets of states from $\Ded(\Delta_M,\varepsilon,\mathsf{o}^{j})$, where $z!$ is the factorial of $z$.
\item[Step 2] Building vertexes by the sets of states. 
\end{description}
 \item Sort the states in these vertexes and sort these vertexes: We sort the states inside the vertexes at first, and then sort the vertexes by the states of them. For example, in Fig.~\ref{fig:4} the vertexes $\{\delta_{16}^0,\delta_{16}^1\}$, $\{\delta_{16}^0,\delta_{16}^2\}$ and $\{\delta_{16}^1,\delta_{16}^2\}$ are well shorted. 
  \item Find $InputArray$ by other vertexes:
   For the vertex $VertexArray[i]$ contains $z$ sorted states, we use the vertexe with the first $(z-1)$ states and the vertexe with the last $(z-1)$ states to find $InputArray$ for $VertexArray[i]$. For example, in Fig.~\ref{fig:4}, $\Ri(\{\delta_{16}^0,\delta_{16}^1\})=\{\delta_{4}^0,\delta_{4}^2,\delta_{4}^3\}$ and $\Ri(\{\delta_{16}^1,\delta_{16}^2\})=\{\delta_{4}^0,\delta_{4}^1,\delta_{4}^3\}$. Then we can take the intersection of them to be $InputArray$ of $\{\delta_{16}^0,\delta_{16}^1,\delta_{16}^2\}$ i.e. $InputArray=\{\delta_{4}^0,\delta_{4}^3\}$. 
  \item Check $VertexArray[i]$ by $InputArray[j]$:
     
\begin{itemize}
\item If the $|\Ded(VertexArray[i],InputArray[j],\varepsilon)|<|VertexArray[i]|$, then the $InputArray[j]$ is a wrong input.
\item Else if every non-empty \\$\Ded\left(VertexArray[i],InputArray[j],\mathsf{o}^{p}\right)$ already exists in the directed graph, then connect $VertexArray[i]$ to it and label the edge with $InputArray[j]$, else we check it latter. 
\end{itemize} 
\end{itemize} 


%With the algorithm based on directed graph we can find all paths to determine the initial state of a \BCN. Thus, at time step $t$, we can use the $\mathsf{S}(t)$ and the directed graph to derive all of the input $\mathsf{i}(t)$ which can help us determine $\mathsf{s}(0)$. While, there comes a problem. Which input is the best input? To solve this problem, in the {\em Section \ref{sec:app}}, we will present how to decide the input to get better performance.
